--- a/lib/platform/std/src/impl/runtime.zig
+++ b/lib/platform/std/src/impl/runtime.zig
@@ -62,6 +62,12 @@
     pub fn broadcast(self: *Condition) void {
         self.inner.broadcast();
     }
+
+    /// Wait with timeout. Returns true if timed out (no signal received).
+    pub fn timedWait(self: *Condition, mutex: *Mutex, timeout_ns: u64) bool {
+        self.inner.timedWait(&mutex.inner, timeout_ns) catch return true;
+        return false;
+    }
 };
 
 /// Task spawn options
@@ -108,7 +114,66 @@
     return @intCast(std.time.milliTimestamp());
 }
 
+/// Sleep for the given number of milliseconds.
+pub fn sleepMs(ms: u32) void {
+    std.Thread.sleep(@as(u64, ms) * std.time.ns_per_ms);
+}
+
 // ============================================================================
+// Notify â€” Lightweight event notification via pipe
+// ============================================================================
+
+/// Lightweight one-shot event notification using a pipe fd pair.
+/// Faster than Mutex+Condition for "wake up" signaling because
+/// signal() is a single write() syscall (no mutex lock required),
+/// and timedWait() uses poll() (no mutex contention).
+pub const Notify = struct {
+    read_fd: std.posix.fd_t,
+    write_fd: std.posix.fd_t,
+
+    pub fn init() Notify {
+        const fds = std.posix.pipe() catch unreachable;
+        return .{ .read_fd = fds[0], .write_fd = fds[1] };
+    }
+
+    pub fn deinit(self: *Notify) void {
+        std.posix.close(self.read_fd);
+        std.posix.close(self.write_fd);
+    }
+
+    /// Signal the notification. Non-blocking, thread-safe.
+    pub fn signal(self: *Notify) void {
+        _ = std.posix.write(self.write_fd, &[_]u8{1}) catch {};
+    }
+
+    /// Block until signaled. Consumes the notification.
+    pub fn wait(self: *Notify) void {
+        var buf: [8]u8 = undefined;
+        _ = std.posix.read(self.read_fd, &buf) catch {};
+    }
+
+    /// Wait with timeout (nanoseconds). Returns true if signaled, false if timed out.
+    pub fn timedWait(self: *Notify, timeout_ns: u64) bool {
+        const timeout_ms: i32 = if (timeout_ns >= @as(u64, @intCast(std.math.maxInt(i32))) * std.time.ns_per_ms)
+            std.math.maxInt(i32)
+        else
+            @intCast(timeout_ns / std.time.ns_per_ms);
+        var pfd = [1]std.posix.pollfd{.{
+            .fd = self.read_fd,
+            .events = std.posix.POLL.IN,
+            .revents = 0,
+        }};
+        const ret = std.posix.poll(&pfd, timeout_ms) catch return false;
+        if (ret > 0) {
+            var buf: [8]u8 = undefined;
+            _ = std.posix.read(self.read_fd, &buf) catch {};
+            return true;
+        }
+        return false;
+    }
+};
+
+// ============================================================================
 // CPU Info
 // ============================================================================
 
@@ -200,3 +265,63 @@
     const count = try getCpuCount();
     try std.testing.expect(count >= 1);
 }
+
+test "Condition timedWait timeout" {
+    var mutex = Mutex.init();
+    defer mutex.deinit();
+    var cond = Condition.init();
+    defer cond.deinit();
+
+    mutex.lock();
+    const timed_out = cond.timedWait(&mutex, 1 * std.time.ns_per_ms);
+    mutex.unlock();
+    try std.testing.expect(timed_out);
+}
+
+test "Notify signal and wait" {
+    var notify = Notify.init();
+    defer notify.deinit();
+
+    const t = try std.Thread.spawn(.{}, struct {
+        fn run(n: *Notify) void {
+            std.Thread.sleep(5 * std.time.ns_per_ms);
+            n.signal();
+        }
+    }.run, .{&notify});
+
+    notify.wait();
+    t.join();
+}
+
+test "Notify timedWait timeout" {
+    var notify = Notify.init();
+    defer notify.deinit();
+
+    const start = std.time.nanoTimestamp();
+    const signaled = notify.timedWait(10 * std.time.ns_per_ms);
+    const elapsed_ms = @divFloor(@as(u64, @intCast(std.time.nanoTimestamp() - start)), std.time.ns_per_ms);
+
+    try std.testing.expect(!signaled);
+    try std.testing.expect(elapsed_ms >= 5);
+}
+
+test "Notify timedWait signaled" {
+    var notify = Notify.init();
+    defer notify.deinit();
+
+    notify.signal();
+    const signaled = notify.timedWait(1000 * std.time.ns_per_ms);
+    try std.testing.expect(signaled);
+}
+
+test "Notify multiple signals coalesce" {
+    var notify = Notify.init();
+    defer notify.deinit();
+
+    notify.signal();
+    notify.signal();
+    notify.signal();
+
+    const s1 = notify.timedWait(10 * std.time.ns_per_ms);
+    try std.testing.expect(s1);
+}
