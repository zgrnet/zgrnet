package lan

import (
	"crypto/rand"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"sync"

	"github.com/vibing/zgrnet/pkg/noise"
	"golang.org/x/crypto/bcrypt"
)

// Authenticator validates a join request.
// Implementations decide whether a peer with the given pubkey is allowed
// to join the LAN based on the provided credential.
type Authenticator interface {
	// Method returns the authentication method name (e.g., "open", "invite_code").
	// This must match the "method" field in the join request body.
	Method() string

	// Authenticate checks whether the peer is allowed to join.
	// credential is the raw JSON value from the "credential" field in the
	// join request. It may be null for methods that don't require credentials.
	// Returns nil on success, or an error describing why authentication failed.
	Authenticate(pubkey noise.PublicKey, credential json.RawMessage) error
}

// AuthRequest is the authentication payload in a join request.
type AuthRequest struct {
	Method     string          `json:"method"`
	Credential json.RawMessage `json:"credential"`
}

// ── OpenAuth ────────────────────────────────────────────────────────────────

// OpenAuth allows any peer to join without credentials.
type OpenAuth struct{}

func NewOpenAuth() *OpenAuth { return &OpenAuth{} }

func (a *OpenAuth) Method() string { return "open" }

func (a *OpenAuth) Authenticate(_ noise.PublicKey, _ json.RawMessage) error {
	return nil
}

// ── PasswordAuth ────────────────────────────────────────────────────────────

// PasswordAuth validates join requests against a bcrypt-hashed password.
type PasswordAuth struct {
	hash []byte // bcrypt hash
}

// NewPasswordAuth creates a password authenticator from an existing bcrypt hash.
func NewPasswordAuth(bcryptHash string) (*PasswordAuth, error) {
	// Verify it's a valid bcrypt hash by checking the prefix.
	if len(bcryptHash) < 4 || bcryptHash[:4] != "$2a$" && bcryptHash[:4] != "$2b$" {
		return nil, fmt.Errorf("lan: invalid bcrypt hash")
	}
	return &PasswordAuth{hash: []byte(bcryptHash)}, nil
}

// NewPasswordAuthFromPlaintext creates a password authenticator by hashing
// the given plaintext password with bcrypt. Use cost=12 for a good balance
// of security and performance.
func NewPasswordAuthFromPlaintext(password string, cost int) (*PasswordAuth, error) {
	if cost < bcrypt.MinCost || cost > bcrypt.MaxCost {
		cost = bcrypt.DefaultCost
	}
	hash, err := bcrypt.GenerateFromPassword([]byte(password), cost)
	if err != nil {
		return nil, fmt.Errorf("lan: hash password: %w", err)
	}
	return &PasswordAuth{hash: hash}, nil
}

func (a *PasswordAuth) Method() string { return "password" }

// passwordCredential is the expected JSON credential for password auth.
type passwordCredential struct {
	Password string `json:"password"`
}

func (a *PasswordAuth) Authenticate(_ noise.PublicKey, credential json.RawMessage) error {
	var cred passwordCredential
	if err := json.Unmarshal(credential, &cred); err != nil {
		return fmt.Errorf("invalid credential: expected {\"password\": \"...\"}")
	}
	if cred.Password == "" {
		return fmt.Errorf("password is required")
	}
	if err := bcrypt.CompareHashAndPassword(a.hash, []byte(cred.Password)); err != nil {
		return fmt.Errorf("invalid password")
	}
	return nil
}

// ── InviteCodeAuth ──────────────────────────────────────────────────────────

// InviteCode represents a generated invite code.
type InviteCode struct {
	Code     string `json:"code"`
	MaxUses  int    `json:"max_uses"`  // 0 = unlimited
	UseCount int    `json:"use_count"`
}

// InviteCodeAuth validates join requests against invite codes.
// Codes are generated by admins and can be single-use or multi-use.
type InviteCodeAuth struct {
	mu    sync.Mutex
	codes map[string]*InviteCode
}

func NewInviteCodeAuth() *InviteCodeAuth {
	return &InviteCodeAuth{
		codes: make(map[string]*InviteCode),
	}
}

func (a *InviteCodeAuth) Method() string { return "invite_code" }

// inviteCodeCredential is the expected JSON credential for invite code auth.
type inviteCodeCredential struct {
	Code string `json:"code"`
}

func (a *InviteCodeAuth) Authenticate(_ noise.PublicKey, credential json.RawMessage) error {
	var cred inviteCodeCredential
	if err := json.Unmarshal(credential, &cred); err != nil {
		return fmt.Errorf("invalid credential: expected {\"code\": \"...\"}")
	}
	if cred.Code == "" {
		return fmt.Errorf("invite code is required")
	}

	a.mu.Lock()
	defer a.mu.Unlock()

	ic, ok := a.codes[cred.Code]
	if !ok {
		return fmt.Errorf("invalid invite code")
	}

	if ic.MaxUses > 0 && ic.UseCount >= ic.MaxUses {
		return fmt.Errorf("invite code has been fully used")
	}

	ic.UseCount++
	return nil
}

// GenerateCode creates a new invite code. maxUses=0 means unlimited.
// Returns the generated code string.
func (a *InviteCodeAuth) GenerateCode(maxUses int) (string, error) {
	var buf [16]byte
	if _, err := rand.Read(buf[:]); err != nil {
		return "", fmt.Errorf("lan: generate invite code: %w", err)
	}
	code := hex.EncodeToString(buf[:])

	a.mu.Lock()
	defer a.mu.Unlock()

	a.codes[code] = &InviteCode{
		Code:    code,
		MaxUses: maxUses,
	}

	return code, nil
}

// RevokeCode removes an invite code.
func (a *InviteCodeAuth) RevokeCode(code string) bool {
	a.mu.Lock()
	defer a.mu.Unlock()

	if _, ok := a.codes[code]; !ok {
		return false
	}
	delete(a.codes, code)
	return true
}

// ListCodes returns all active invite codes.
func (a *InviteCodeAuth) ListCodes() []InviteCode {
	a.mu.Lock()
	defer a.mu.Unlock()

	result := make([]InviteCode, 0, len(a.codes))
	for _, ic := range a.codes {
		result = append(result, *ic)
	}
	return result
}

// ── PubkeyWhitelistAuth ────────────────────────────────────────────────────

// PubkeyWhitelistAuth allows only pre-approved public keys to join.
// No credential is needed — the peer's pubkey is the credential.
type PubkeyWhitelistAuth struct {
	mu      sync.RWMutex
	allowed map[noise.PublicKey]bool
}

func NewPubkeyWhitelistAuth(keys []noise.PublicKey) *PubkeyWhitelistAuth {
	allowed := make(map[noise.PublicKey]bool, len(keys))
	for _, k := range keys {
		allowed[k] = true
	}
	return &PubkeyWhitelistAuth{allowed: allowed}
}

func (a *PubkeyWhitelistAuth) Method() string { return "pubkey_whitelist" }

func (a *PubkeyWhitelistAuth) Authenticate(pubkey noise.PublicKey, _ json.RawMessage) error {
	a.mu.RLock()
	defer a.mu.RUnlock()

	if !a.allowed[pubkey] {
		return fmt.Errorf("pubkey not in whitelist")
	}
	return nil
}

// AddKey adds a public key to the whitelist.
func (a *PubkeyWhitelistAuth) AddKey(pk noise.PublicKey) {
	a.mu.Lock()
	defer a.mu.Unlock()
	a.allowed[pk] = true
}

// RemoveKey removes a public key from the whitelist.
func (a *PubkeyWhitelistAuth) RemoveKey(pk noise.PublicKey) {
	a.mu.Lock()
	defer a.mu.Unlock()
	delete(a.allowed, pk)
}

