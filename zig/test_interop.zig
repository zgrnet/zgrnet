//! Standalone cross-language interoperability test.
//! Run with: zig run test_interop.zig

const std = @import("std");
const crypto_std = std.crypto;

// Import from relative paths
const keypair = @import("src/noise/keypair.zig");
const crypto = @import("src/noise/crypto.zig");
const Key = keypair.Key;
const KeyPair = keypair.KeyPair;

// Minimal SymmetricState for testing (without build_options dependency)
const SymmetricState = struct {
    chaining_key: Key,
    hash: [32]u8,

    pub fn init(protocol_name: []const u8) SymmetricState {
        var chaining_key: [32]u8 = [_]u8{0} ** 32;
        if (protocol_name.len <= 32) {
            @memcpy(chaining_key[0..protocol_name.len], protocol_name);
        } else {
            chaining_key = crypto.hash(&.{protocol_name});
        }
        return .{
            .chaining_key = Key.fromBytes(chaining_key),
            .hash = chaining_key,
        };
    }

    pub fn mixHash(self: *SymmetricState, data: []const u8) void {
        self.hash = crypto.hash(&.{ &self.hash, data });
    }

    pub fn mixKey(self: *SymmetricState, input: []const u8) Key {
        const new_ck, const k = crypto.kdf2(&self.chaining_key, input);
        self.chaining_key = new_ck;
        return k;
    }

    pub fn encryptAndHash(self: *SymmetricState, key: *const Key, plaintext: []const u8, out: []u8) void {
        // ChaCha20-Poly1305 with zero nonce and hash as AD
        const aead = crypto_std.aead.chacha_poly.ChaCha20Poly1305;
        var tag: [16]u8 = undefined;
        const nonce = [_]u8{0} ** 12;
        aead.encrypt(out[0..plaintext.len], &tag, plaintext, &self.hash, nonce, key.asBytes().*);
        @memcpy(out[plaintext.len..][0..16], &tag);
        self.mixHash(out[0 .. plaintext.len + 16]);
    }

    pub fn decryptAndHash(self: *SymmetricState, key: *const Key, ciphertext: []const u8, out: []u8) !void {
        const aead = crypto_std.aead.chacha_poly.ChaCha20Poly1305;
        const pt_len = ciphertext.len - 16;
        const tag = ciphertext[pt_len..][0..16];
        const nonce = [_]u8{0} ** 12;
        aead.decrypt(out[0..pt_len], ciphertext[0..pt_len], tag.*, &self.hash, nonce, key.asBytes().*) catch {
            return error.DecryptionFailed;
        };
        self.mixHash(ciphertext);
    }
};

fn hexDigit(c: u8) u8 {
    return switch (c) {
        '0'...'9' => c - '0',
        'a'...'f' => c - 'a' + 10,
        'A'...'F' => c - 'A' + 10,
        else => 0,
    };
}

fn hexDecode(hex: []const u8, out: []u8) void {
    for (0..hex.len / 2) |i| {
        out[i] = (hexDigit(hex[i * 2]) << 4) | hexDigit(hex[i * 2 + 1]);
    }
}

fn printHex(label: []const u8, data: []const u8) void {
    std.debug.print("{s}: ", .{label});
    for (data) |b| {
        std.debug.print("{x:0>2}", .{b});
    }
    std.debug.print("\n", .{});
}

pub fn main() !void {
    std.debug.print("\n=== Cross-Language Interop Test ===\n\n", .{});

    // Test vectors from Go (generated by go/noise/test_vectors.go)
    const initiator_priv_hex = "0002030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f60";
    const initiator_pub_hex = "07a37cbc142093c8b755dc1b10e86cb426374ad16aa853ed0bdfc0b2b86d1c7c";
    const responder_pub_hex = "5869aff450549732cbaaed5e5df9b30a6da31cb0e5742bad5ad4a1a768f1a67b";
    const ephemeral_priv_hex = "4042434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f60";
    const ephemeral_pub_hex = "64b101b1d0be5a8704bd078f9895001fc03e8e9f9522f188dd128d9846d48466";

    const expected_init_ck = "bbea022b948cf3bc5857d70804229179e1116bc40cb8cc074835349c464bca36";
    const expected_init_h = "bbea022b948cf3bc5857d70804229179e1116bc40cb8cc074835349c464bca36";
    const expected_mixhash_prologue_h = "2f289177342da72536c1c74b8e1cf18b28b8a914918d02dcbce0f57c61e585b8";
    const expected_mixhash_rs_h = "747d06f14e43bc15532cf7c82537c550df6fc899c8381a5831072af443502d32";
    const expected_mixhash_e_h = "7a1cd87537c973bc006ad3fff68a41ec943a848ccde6cf6fa87275b78e020e69";
    const expected_dh_e_rs = "b6ddcb217f2edb78fe01f0d967925f1e3fda132789e4566ddc2abcd3e2fd9526";
    const expected_mixkey_es_ck = "38fc1e0f50fa0a434a77591d4fef6b8f41d7d90e731bbd396c612000e9bebf3b";
    const expected_mixkey_es_k = "72983ab268c95e1da719d65a6b96ea64096145ecd76f49e69d0ddcceefe1ad3e";
    const expected_mixkey_before_s_ck = "6138d0c86fd78fff405d33a24a54893340497f30c927adf441c37c1e98d7778e";
    const expected_mixkey_before_s_k = "bea6c3578c5aba1e77627bebe825e8a149c7ece608cb196f5c5518374fd10c88";

    var all_passed = true;

    // Test 1: Keypair derivation
    std.debug.print("Test 1: Keypair derivation\n", .{});
    {
        var initiator_priv: [32]u8 = undefined;
        var initiator_expected_pub: [32]u8 = undefined;
        hexDecode(initiator_priv_hex, &initiator_priv);
        hexDecode(initiator_pub_hex, &initiator_expected_pub);

        const initiator_kp = KeyPair.fromPrivate(Key.fromBytes(initiator_priv));
        printHex("  Initiator pub (Zig)", initiator_kp.public.asBytes());
        printHex("  Initiator pub (Go)", &initiator_expected_pub);

        if (!std.mem.eql(u8, initiator_kp.public.asBytes(), &initiator_expected_pub)) {
            std.debug.print("  FAIL: Keypair derivation mismatch!\n", .{});
            all_passed = false;
        } else {
            std.debug.print("  PASS\n", .{});
        }
    }

    // Test 2: Protocol name init
    std.debug.print("\nTest 2: SymmetricState init\n", .{});
    {
        const protocol_name = "Noise_IK_25519_ChaChaPoly_BLAKE2s";
        var ss = SymmetricState.init(protocol_name);

        var expected_ck: [32]u8 = undefined;
        var expected_h: [32]u8 = undefined;
        hexDecode(expected_init_ck, &expected_ck);
        hexDecode(expected_init_h, &expected_h);

        printHex("  ck (Zig)", ss.chaining_key.asBytes());
        printHex("  ck (Go)", &expected_ck);

        if (!std.mem.eql(u8, ss.chaining_key.asBytes(), &expected_ck)) {
            std.debug.print("  FAIL: chaining_key mismatch!\n", .{});
            all_passed = false;
        } else if (!std.mem.eql(u8, &ss.hash, &expected_h)) {
            std.debug.print("  FAIL: hash mismatch!\n", .{});
            all_passed = false;
        } else {
            std.debug.print("  PASS\n", .{});
        }
    }

    // Test 3: MixHash(prologue)
    std.debug.print("\nTest 3: MixHash(prologue=[])\n", .{});
    var ss = SymmetricState.init("Noise_IK_25519_ChaChaPoly_BLAKE2s");
    {
        ss.mixHash("");

        var expected_h: [32]u8 = undefined;
        hexDecode(expected_mixhash_prologue_h, &expected_h);

        printHex("  h (Zig)", &ss.hash);
        printHex("  h (Go)", &expected_h);

        if (!std.mem.eql(u8, &ss.hash, &expected_h)) {
            std.debug.print("  FAIL: hash mismatch!\n", .{});
            all_passed = false;
        } else {
            std.debug.print("  PASS\n", .{});
        }
    }

    // Test 4: MixHash(responder_public)
    std.debug.print("\nTest 4: MixHash(responder_public)\n", .{});
    {
        var responder_pub: [32]u8 = undefined;
        hexDecode(responder_pub_hex, &responder_pub);
        ss.mixHash(&responder_pub);

        var expected_h: [32]u8 = undefined;
        hexDecode(expected_mixhash_rs_h, &expected_h);

        printHex("  h (Zig)", &ss.hash);
        printHex("  h (Go)", &expected_h);

        if (!std.mem.eql(u8, &ss.hash, &expected_h)) {
            std.debug.print("  FAIL: hash mismatch!\n", .{});
            all_passed = false;
        } else {
            std.debug.print("  PASS\n", .{});
        }
    }

    // Test 5: MixHash(ephemeral_public)
    std.debug.print("\nTest 5: MixHash(ephemeral_public)\n", .{});
    {
        var ephemeral_pub: [32]u8 = undefined;
        hexDecode(ephemeral_pub_hex, &ephemeral_pub);
        ss.mixHash(&ephemeral_pub);

        var expected_h: [32]u8 = undefined;
        hexDecode(expected_mixhash_e_h, &expected_h);

        printHex("  h (Zig)", &ss.hash);
        printHex("  h (Go)", &expected_h);

        if (!std.mem.eql(u8, &ss.hash, &expected_h)) {
            std.debug.print("  FAIL: hash mismatch!\n", .{});
            all_passed = false;
        } else {
            std.debug.print("  PASS\n", .{});
        }
    }

    // Test 6: DH(e, rs)
    std.debug.print("\nTest 6: DH(ephemeral, responder_static)\n", .{});
    var dh_result: [32]u8 = undefined;
    {
        var ephemeral_priv: [32]u8 = undefined;
        var responder_pub: [32]u8 = undefined;
        hexDecode(ephemeral_priv_hex, &ephemeral_priv);
        hexDecode(responder_pub_hex, &responder_pub);

        const ephemeral_kp = KeyPair.fromPrivate(Key.fromBytes(ephemeral_priv));
        const dh = ephemeral_kp.dh(Key.fromBytes(responder_pub)) catch {
            std.debug.print("  FAIL: DH failed!\n", .{});
            all_passed = false;
            return;
        };
        @memcpy(&dh_result, dh.asBytes());

        var expected_dh: [32]u8 = undefined;
        hexDecode(expected_dh_e_rs, &expected_dh);

        printHex("  DH (Zig)", dh.asBytes());
        printHex("  DH (Go)", &expected_dh);

        if (!std.mem.eql(u8, dh.asBytes(), &expected_dh)) {
            std.debug.print("  FAIL: DH mismatch!\n", .{});
            all_passed = false;
        } else {
            std.debug.print("  PASS\n", .{});
        }
    }

    // Test 7: MixKey(DH result)
    std.debug.print("\nTest 7: MixKey(DH(e, rs))\n", .{});
    {
        const k = ss.mixKey(&dh_result);

        var expected_ck: [32]u8 = undefined;
        var expected_k: [32]u8 = undefined;
        hexDecode(expected_mixkey_es_ck, &expected_ck);
        hexDecode(expected_mixkey_es_k, &expected_k);

        printHex("  ck (Zig)", ss.chaining_key.asBytes());
        printHex("  ck (Go)", &expected_ck);
        printHex("  k (Zig)", k.asBytes());
        printHex("  k (Go)", &expected_k);

        if (!std.mem.eql(u8, ss.chaining_key.asBytes(), &expected_ck)) {
            std.debug.print("  FAIL: chaining_key mismatch!\n", .{});
            all_passed = false;
        } else if (!std.mem.eql(u8, k.asBytes(), &expected_k)) {
            std.debug.print("  FAIL: key mismatch!\n", .{});
            all_passed = false;
        } else {
            std.debug.print("  PASS\n", .{});
        }
    }

    // Test 8: MixKey(nil) for encrypting s
    std.debug.print("\nTest 8: MixKey(nil) for encrypting s\n", .{});
    {
        const k = ss.mixKey("");

        var expected_ck: [32]u8 = undefined;
        var expected_k: [32]u8 = undefined;
        hexDecode(expected_mixkey_before_s_ck, &expected_ck);
        hexDecode(expected_mixkey_before_s_k, &expected_k);

        printHex("  ck (Zig)", ss.chaining_key.asBytes());
        printHex("  ck (Go)", &expected_ck);
        printHex("  k (Zig)", k.asBytes());
        printHex("  k (Go)", &expected_k);

        if (!std.mem.eql(u8, ss.chaining_key.asBytes(), &expected_ck)) {
            std.debug.print("  FAIL: chaining_key mismatch!\n", .{});
            all_passed = false;
        } else if (!std.mem.eql(u8, k.asBytes(), &expected_k)) {
            std.debug.print("  FAIL: key mismatch!\n", .{});
            all_passed = false;
        } else {
            std.debug.print("  PASS\n", .{});
        }
    }

    // Test 9: Full handshake simulation (as responder receiving initiator's message)
    std.debug.print("\nTest 9: Full handshake (responder side)\n", .{});
    {
        // This simulates what happens when Zig receives a handshake init from Go:
        // 1. Responder creates HS with local_static = responder_keypair
        // 2. Pre-message: MixHash(responder_public) - responder's own public key
        // 3. Receive: e, es, s, ss
        //    - Read e: MixHash(initiator_ephemeral)
        //    - es: MixKey(DH(responder_static, initiator_ephemeral))
        //    - s: MixKey(nil), DecryptAndHash(encrypted_initiator_static)
        //    - ss: MixKey(DH(responder_static, initiator_static))

        // Setup as Go would do for initiator
        var initiator_priv: [32]u8 = undefined;
        var responder_priv: [32]u8 = undefined;
        var responder_pub: [32]u8 = undefined;
        var ephemeral_priv: [32]u8 = undefined;
        hexDecode(initiator_priv_hex, &initiator_priv);
        hexDecode("2022232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f40", &responder_priv);
        hexDecode(responder_pub_hex, &responder_pub);
        hexDecode(ephemeral_priv_hex, &ephemeral_priv);

        const initiator_kp = KeyPair.fromPrivate(Key.fromBytes(initiator_priv));
        const responder_kp = KeyPair.fromPrivate(Key.fromBytes(responder_priv));
        const ephemeral_kp = KeyPair.fromPrivate(Key.fromBytes(ephemeral_priv));

        // === INITIATOR SIDE (simulating Go) ===
        var initiator_ss = SymmetricState.init("Noise_IK_25519_ChaChaPoly_BLAKE2s");
        initiator_ss.mixHash(""); // prologue
        initiator_ss.mixHash(responder_kp.public.asBytes()); // pre-message: responder's static

        // Token e: send ephemeral
        initiator_ss.mixHash(ephemeral_kp.public.asBytes());

        // Token es: DH(e, rs)
        const dh_es_i = ephemeral_kp.dh(responder_kp.public) catch unreachable;
        _ = initiator_ss.mixKey(dh_es_i.asBytes());

        // Token s: encrypt and send initiator's static
        const k_for_s = initiator_ss.mixKey("");
        var encrypted_s: [32 + 16]u8 = undefined;
        initiator_ss.encryptAndHash(&k_for_s, initiator_kp.public.asBytes(), &encrypted_s);

        // Token ss: DH(s, rs)
        const dh_ss_i = initiator_kp.dh(responder_kp.public) catch unreachable;
        _ = initiator_ss.mixKey(dh_ss_i.asBytes());

        std.debug.print("  Initiator encrypted_s: ", .{});
        for (encrypted_s) |b| std.debug.print("{x:0>2}", .{b});
        std.debug.print("\n", .{});

        // === RESPONDER SIDE (simulating Zig) ===
        var responder_ss = SymmetricState.init("Noise_IK_25519_ChaChaPoly_BLAKE2s");
        responder_ss.mixHash(""); // prologue
        responder_ss.mixHash(responder_kp.public.asBytes()); // pre-message: own static

        // Token e: receive ephemeral
        responder_ss.mixHash(ephemeral_kp.public.asBytes());

        // Token es: DH(s, re) where s=responder_static, re=initiator_ephemeral
        const dh_es_r = responder_kp.dh(ephemeral_kp.public) catch unreachable;
        _ = responder_ss.mixKey(dh_es_r.asBytes());

        // Compare DH results
        std.debug.print("  DH es (initiator): ", .{});
        for (dh_es_i.asBytes()) |b| std.debug.print("{x:0>2}", .{b});
        std.debug.print("\n", .{});
        std.debug.print("  DH es (responder): ", .{});
        for (dh_es_r.asBytes()) |b| std.debug.print("{x:0>2}", .{b});
        std.debug.print("\n", .{});

        if (!std.mem.eql(u8, dh_es_i.asBytes(), dh_es_r.asBytes())) {
            std.debug.print("  FAIL: DH es mismatch!\n", .{});
            all_passed = false;
        }

        // Token s: decrypt initiator's static
        const k_for_s_r = responder_ss.mixKey("");
        std.debug.print("  Key for s (initiator): ", .{});
        for (k_for_s.asBytes()) |b| std.debug.print("{x:0>2}", .{b});
        std.debug.print("\n", .{});
        std.debug.print("  Key for s (responder): ", .{});
        for (k_for_s_r.asBytes()) |b| std.debug.print("{x:0>2}", .{b});
        std.debug.print("\n", .{});

        if (!std.mem.eql(u8, k_for_s.asBytes(), k_for_s_r.asBytes())) {
            std.debug.print("  FAIL: Key for s mismatch!\n", .{});
            all_passed = false;
        }

        var decrypted_s: [32]u8 = undefined;
        responder_ss.decryptAndHash(&k_for_s_r, &encrypted_s, &decrypted_s) catch {
            std.debug.print("  FAIL: DecryptAndHash failed!\n", .{});
            all_passed = false;
        };

        std.debug.print("  Decrypted initiator static: ", .{});
        for (decrypted_s) |b| std.debug.print("{x:0>2}", .{b});
        std.debug.print("\n", .{});
        std.debug.print("  Expected initiator static:  ", .{});
        for (initiator_kp.public.asBytes()) |b| std.debug.print("{x:0>2}", .{b});
        std.debug.print("\n", .{});

        if (!std.mem.eql(u8, &decrypted_s, initiator_kp.public.asBytes())) {
            std.debug.print("  FAIL: Decrypted static key mismatch!\n", .{});
            all_passed = false;
        } else {
            std.debug.print("  PASS: Full handshake simulation works!\n", .{});
        }
    }

    // Test 10: Wire format simulation (using config.json keys)
    std.debug.print("\nTest 10: Wire format with config.json keys\n", .{});
    {
        // Keys from config.json
        var go_priv: [32]u8 = undefined;
        var zig_priv: [32]u8 = undefined;
        hexDecode("0000000000000000000000000000000000000000000000000000000000000001", &go_priv);
        hexDecode("0000000000000000000000000000000000000000000000000000000000000003", &zig_priv);

        const go_kp = KeyPair.fromPrivate(Key.fromBytes(go_priv));
        const zig_kp = KeyPair.fromPrivate(Key.fromBytes(zig_priv));

        std.debug.print("  Go public key: ", .{});
        for (go_kp.public.asBytes()) |b| std.debug.print("{x:0>2}", .{b});
        std.debug.print("\n", .{});
        std.debug.print("  Zig public key: ", .{});
        for (zig_kp.public.asBytes()) |b| std.debug.print("{x:0>2}", .{b});
        std.debug.print("\n", .{});

        // Simulate Go (initiator) sending to Zig (responder)
        // Go knows Zig's public key
        var go_ss = SymmetricState.init("Noise_IK_25519_ChaChaPoly_BLAKE2s");
        go_ss.mixHash(""); // prologue
        go_ss.mixHash(zig_kp.public.asBytes()); // pre-message: zig's static

        // Generate ephemeral (use deterministic for test)
        var eph_priv: [32]u8 = undefined;
        hexDecode("4000000000000000000000000000000000000000000000000000000000000004", &eph_priv);
        const eph_kp = KeyPair.fromPrivate(Key.fromBytes(eph_priv));

        // Build message: e, es, s, ss
        // e: send ephemeral
        go_ss.mixHash(eph_kp.public.asBytes());

        // es: DH(e, rs)
        const dh_es_go = eph_kp.dh(zig_kp.public) catch unreachable;
        _ = go_ss.mixKey(dh_es_go.asBytes());

        // s: encrypt and send go's static
        const k_for_s_go = go_ss.mixKey("");
        var encrypted_s_go: [32 + 16]u8 = undefined;
        go_ss.encryptAndHash(&k_for_s_go, go_kp.public.asBytes(), &encrypted_s_go);

        // ss: DH(s, rs)
        const dh_ss_go = go_kp.dh(zig_kp.public) catch unreachable;
        _ = go_ss.mixKey(dh_ss_go.asBytes());

        std.debug.print("  Go encrypted static: ", .{});
        for (encrypted_s_go) |b| std.debug.print("{x:0>2}", .{b});
        std.debug.print("\n", .{});

        // Now Zig receives this message
        var zig_ss = SymmetricState.init("Noise_IK_25519_ChaChaPoly_BLAKE2s");
        zig_ss.mixHash(""); // prologue
        zig_ss.mixHash(zig_kp.public.asBytes()); // pre-message: own static

        // e: receive ephemeral
        zig_ss.mixHash(eph_kp.public.asBytes());

        // es: DH(s, re) where s=zig_static, re=go_ephemeral
        const dh_es_zig = zig_kp.dh(eph_kp.public) catch unreachable;
        _ = zig_ss.mixKey(dh_es_zig.asBytes());

        std.debug.print("  DH es (go): ", .{});
        for (dh_es_go.asBytes()) |b| std.debug.print("{x:0>2}", .{b});
        std.debug.print("\n", .{});
        std.debug.print("  DH es (zig): ", .{});
        for (dh_es_zig.asBytes()) |b| std.debug.print("{x:0>2}", .{b});
        std.debug.print("\n", .{});

        // s: decrypt go's static
        const k_for_s_zig = zig_ss.mixKey("");
        std.debug.print("  Key for s (go): ", .{});
        for (k_for_s_go.asBytes()) |b| std.debug.print("{x:0>2}", .{b});
        std.debug.print("\n", .{});
        std.debug.print("  Key for s (zig): ", .{});
        for (k_for_s_zig.asBytes()) |b| std.debug.print("{x:0>2}", .{b});
        std.debug.print("\n", .{});

        var decrypted_s_zig: [32]u8 = undefined;
        zig_ss.decryptAndHash(&k_for_s_zig, &encrypted_s_go, &decrypted_s_zig) catch {
            std.debug.print("  FAIL: DecryptAndHash failed!\n", .{});
            all_passed = false;
        };

        std.debug.print("  Decrypted go static: ", .{});
        for (decrypted_s_zig) |b| std.debug.print("{x:0>2}", .{b});
        std.debug.print("\n", .{});
        std.debug.print("  Expected go static:  ", .{});
        for (go_kp.public.asBytes()) |b| std.debug.print("{x:0>2}", .{b});
        std.debug.print("\n", .{});

        if (!std.mem.eql(u8, &decrypted_s_zig, go_kp.public.asBytes())) {
            std.debug.print("  FAIL: Decrypted static key mismatch!\n", .{});
            all_passed = false;
        } else {
            std.debug.print("  PASS: Wire format with config keys works!\n", .{});
        }
    }

    std.debug.print("\n=== Results ===\n", .{});
    if (all_passed) {
        std.debug.print("All tests PASSED!\n", .{});
    } else {
        std.debug.print("Some tests FAILED!\n", .{});
    }
}
