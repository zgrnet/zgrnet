//! Linux DNS configuration.
//!
//! Supports two strategies:
//! 1. systemd-resolved (preferred): uses resolvectl to set split DNS
//! 2. Direct /etc/resolv.conf: backup original, write new config
//!
//! Detection: check if systemd-resolved is running.

const std = @import("std");
const mod = @import("mod.zig");
const DnsMgrError = mod.DnsMgrError;

const RESOLV_CONF = "/etc/resolv.conf";
const RESOLV_BACKUP = "/etc/resolv.conf.zgrnet-backup";
const FILE_HEADER = "# Generated by zgrnet\n";

pub const LinuxMode = enum {
    unknown,
    systemd_resolved,
    direct,
};

pub const LinuxState = struct {
    mode: LinuxMode,
    iface_name: ?[]const u8,
    backed_up: bool,

    pub fn init() LinuxState {
        return .{
            .mode = .unknown,
            .iface_name = null,
            .backed_up = false,
        };
    }
};

/// Detect whether systemd-resolved is running.
fn detectMode() LinuxMode {
    // Check if systemd-resolved is active
    var child = std.process.Child.init(
        &.{ "systemctl", "is-active", "--quiet", "systemd-resolved.service" },
        std.heap.page_allocator,
    );
    const term = child.spawnAndWait() catch return .direct;
    return switch (term) {
        .Exited => |code| if (code == 0) .systemd_resolved else .direct,
        else => .direct,
    };
}

/// Check if platform supports split DNS.
pub fn supportsSplitDNS() bool {
    return detectMode() == .systemd_resolved;
}

/// Validate nameserver: only IP address characters, no newlines/metacharacters.
/// Prevents CRLF injection into /etc/resolv.conf.
fn validateNameserver(ns: []const u8) bool {
    if (ns.len == 0) return false;
    for (ns) |c| {
        if (!std.ascii.isAlphanumeric(c) and c != '.' and c != ':' and c != '-') {
            return false;
        }
    }
    return true;
}

/// Set DNS configuration.
pub fn setDNS(
    state: *LinuxState,
    nameserver: []const u8,
    domains: []const []const u8,
    iface_name: ?[]const u8,
) DnsMgrError!void {
    if (!validateNameserver(nameserver)) return DnsMgrError.InvalidArgument;
    if (state.mode == .unknown) {
        state.mode = detectMode();
    }
    state.iface_name = iface_name;

    switch (state.mode) {
        .systemd_resolved => try setResolvedDNS(nameserver, domains, iface_name),
        .direct => try setDirectDNS(state, nameserver),
        .unknown => return DnsMgrError.DetectFailed,
    }
}

/// Configure DNS via systemd-resolved using resolvectl.
fn setResolvedDNS(
    nameserver: []const u8,
    domains: []const []const u8,
    iface_name: ?[]const u8,
) DnsMgrError!void {
    const iface = iface_name orelse return DnsMgrError.InvalidArgument;

    // resolvectl dns <iface> <nameserver>
    var dns_child = std.process.Child.init(
        &.{ "resolvectl", "dns", iface, nameserver },
        std.heap.page_allocator,
    );
    const dns_term = dns_child.spawnAndWait() catch return DnsMgrError.SetFailed;
    switch (dns_term) {
        .Exited => |code| if (code != 0) return DnsMgrError.SetFailed,
        else => return DnsMgrError.SetFailed,
    }

    // resolvectl domain <iface> ~domain1 ~domain2 ...
    // Build args: resolvectl domain <iface> ~zigor.net
    var args_buf: [32][]const u8 = undefined;
    var args_count: usize = 0;
    args_buf[args_count] = "resolvectl";
    args_count += 1;
    args_buf[args_count] = "domain";
    args_count += 1;
    args_buf[args_count] = iface;
    args_count += 1;

    // Add ~domain for each domain (the ~ prefix makes it a routing domain)
    var domain_bufs: [16][128]u8 = undefined;
    for (domains, 0..) |domain, i| {
        if (args_count >= args_buf.len or i >= domain_bufs.len) break;
        const tilde_domain = std.fmt.bufPrint(&domain_bufs[i], "~{s}", .{domain}) catch continue;
        args_buf[args_count] = tilde_domain;
        args_count += 1;
    }

    var domain_child = std.process.Child.init(
        args_buf[0..args_count],
        std.heap.page_allocator,
    );
    const domain_term = domain_child.spawnAndWait() catch return DnsMgrError.SetFailed;
    switch (domain_term) {
        .Exited => |code| if (code != 0) return DnsMgrError.SetFailed,
        else => return DnsMgrError.SetFailed,
    }
}

/// Configure DNS by directly editing /etc/resolv.conf.
fn setDirectDNS(state: *LinuxState, nameserver: []const u8) DnsMgrError!void {
    // Backup original if not already backed up
    if (!state.backed_up) {
        std.fs.copyFileAbsolute(RESOLV_CONF, RESOLV_BACKUP, .{}) catch {};
        state.backed_up = true;
    }

    // Write new resolv.conf
    var content_buf: [512]u8 = undefined;
    const content = std.fmt.bufPrint(&content_buf, "{s}nameserver {s}\n", .{ FILE_HEADER, nameserver }) catch return DnsMgrError.SetFailed;

    const file = std.fs.createFileAbsolute(RESOLV_CONF, .{}) catch |err| switch (err) {
        error.AccessDenied => return DnsMgrError.PermissionDenied,
        else => return DnsMgrError.CreateFailed,
    };
    defer file.close();
    file.writeAll(content) catch return DnsMgrError.SetFailed;
}

/// Flush Linux DNS cache.
pub fn flushCache() DnsMgrError!void {
    // If systemd-resolved is running, use resolvectl
    var child = std.process.Child.init(
        &.{ "resolvectl", "flush-caches" },
        std.heap.page_allocator,
    );
    _ = child.spawnAndWait() catch {};
}

/// Remove DNS configuration and restore original state.
pub fn close(state: *LinuxState) void {
    switch (state.mode) {
        .systemd_resolved => {
            if (state.iface_name) |iface| {
                // Reset resolved configuration
                var child = std.process.Child.init(
                    &.{ "resolvectl", "revert", iface },
                    std.heap.page_allocator,
                );
                _ = child.spawnAndWait() catch {};
            }
        },
        .direct => {
            if (state.backed_up) {
                // Restore backup
                std.fs.copyFileAbsolute(RESOLV_BACKUP, RESOLV_CONF, .{}) catch {};
                std.fs.deleteFileAbsolute(RESOLV_BACKUP) catch {};
                state.backed_up = false;
            }
        },
        .unknown => {},
    }
}
