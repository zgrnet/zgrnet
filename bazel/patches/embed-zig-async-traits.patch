diff --git a/lib/platform/std/src/impl/kqueue_io.zig b/lib/platform/std/src/impl/kqueue_io.zig
new file mode 100644
index 0000000..021dc80
--- /dev/null
+++ b/lib/platform/std/src/impl/kqueue_io.zig
@@ -0,0 +1,336 @@
+//! kqueue-based IOService backend for macOS/BSD.
+//!
+//! Provides efficient event-driven I/O using kqueue. Satisfies the
+//! trait.io contract defined in lib/trait/src/io.zig.
+//!
+//! ## Usage
+//!
+//! ```zig
+//! const std_impl = @import("std_impl");
+//! const KqueueIO = std_impl.kqueue_io.KqueueIO;
+//!
+//! var io = try KqueueIO.init(allocator);
+//! defer io.deinit();
+//!
+//! io.registerRead(socket_fd, .{ .ptr = ctx, .callback = onReady });
+//!
+//! while (running) {
+//!     _ = io.poll(-1);  // block until events
+//! }
+//!
+//! // From another thread:
+//! io.wake();  // interrupts blocking poll()
+//! ```
+
+const std = @import("std");
+const posix = std.posix;
+const Allocator = std.mem.Allocator;
+
+/// kqueue-based I/O service implementing the IOService trait contract.
+pub const KqueueIO = struct {
+    const Self = @This();
+    const max_events = 64;
+    const wake_ident: usize = 0xDEAD;
+
+    /// Callback invoked when a file descriptor is ready for I/O.
+    pub const ReadyCallback = struct {
+        /// Opaque pointer to callback context
+        ptr: ?*anyopaque,
+        /// Callback function
+        callback: *const fn (ptr: ?*anyopaque, fd: posix.fd_t) void,
+
+        /// Invoke the callback.
+        pub fn call(self: @This(), fd: posix.fd_t) void {
+            self.callback(self.ptr, fd);
+        }
+
+        /// A no-op callback.
+        pub const noop: @This() = .{
+            .ptr = null,
+            .callback = struct {
+                fn cb(_: ?*anyopaque, _: posix.fd_t) void {}
+            }.cb,
+        };
+    };
+
+    /// Internal registration entry
+    const Entry = struct {
+        fd: posix.fd_t,
+        read_cb: ReadyCallback,
+        write_cb: ReadyCallback,
+        read_registered: bool,
+        write_registered: bool,
+    };
+
+    kq: posix.fd_t,
+    allocator: Allocator,
+    registrations: std.AutoHashMap(posix.fd_t, Entry),
+    events: [max_events]posix.system.Kevent,
+
+    pub fn init(allocator: Allocator) !Self {
+        const kq = try posix.kqueue();
+        errdefer posix.close(kq);
+
+        // Register EVFILT_USER event for wake() signaling
+        const changelist = [_]posix.system.Kevent{.{
+            .ident = wake_ident,
+            .filter = posix.system.EVFILT.USER,
+            .flags = posix.system.EV.ADD | posix.system.EV.CLEAR,
+            .fflags = 0,
+            .data = 0,
+            .udata = 0,
+        }};
+        _ = try posix.kevent(kq, &changelist, &[_]posix.system.Kevent{}, null);
+
+        return .{
+            .kq = kq,
+            .allocator = allocator,
+            .registrations = std.AutoHashMap(posix.fd_t, Entry).init(allocator),
+            .events = undefined,
+        };
+    }
+
+    pub fn deinit(self: *Self) void {
+        posix.close(self.kq);
+        self.registrations.deinit();
+    }
+
+    /// Register a file descriptor for read readiness.
+    pub fn registerRead(self: *Self, fd: posix.fd_t, callback: ReadyCallback) void {
+        self.registerFilter(fd, posix.system.EVFILT.READ, callback);
+    }
+
+    /// Register a file descriptor for write readiness.
+    pub fn registerWrite(self: *Self, fd: posix.fd_t, callback: ReadyCallback) void {
+        self.registerFilter(fd, posix.system.EVFILT.WRITE, callback);
+    }
+
+    /// Shared implementation for registering a filter on a file descriptor.
+    fn registerFilter(self: *Self, fd: posix.fd_t, filter: i8, callback: ReadyCallback) void {
+        const result = self.registrations.getOrPut(fd) catch |err| {
+            std.log.err("KqueueIO: failed to update registration map for fd {d}: {s}", .{ fd, @errorName(err) });
+            return;
+        };
+        const is_new = !result.found_existing;
+        if (is_new) {
+            result.value_ptr.* = .{
+                .fd = fd,
+                .read_cb = ReadyCallback.noop,
+                .write_cb = ReadyCallback.noop,
+                .read_registered = false,
+                .write_registered = false,
+            };
+        }
+
+        const is_read = (filter == posix.system.EVFILT.READ);
+        if (is_read) {
+            result.value_ptr.read_cb = callback;
+        } else {
+            result.value_ptr.write_cb = callback;
+        }
+
+        const already_registered = if (is_read) result.value_ptr.read_registered else result.value_ptr.write_registered;
+        if (!already_registered) {
+            // Use level-triggered (no EV_CLEAR). Edge-triggered events
+            // require the caller to fully drain the fd on each callback;
+            // if it cannot (e.g. pool exhaustion in UDP), remaining data
+            // in the socket buffer would never trigger a new event, causing
+            // an indefinite stall. Level-triggered keeps firing while the
+            // condition holds, so a transient inability to drain is safe.
+            const changelist = [_]posix.system.Kevent{.{
+                .ident = @intCast(fd),
+                .filter = filter,
+                .flags = posix.system.EV.ADD,
+                .fflags = 0,
+                .data = 0,
+                .udata = 0,
+            }};
+            _ = posix.kevent(self.kq, &changelist, &[_]posix.system.Kevent{}, null) catch |err| {
+                std.log.err("KqueueIO: failed to register fd {d} with kqueue: {s}", .{ fd, @errorName(err) });
+                if (is_new) {
+                    _ = self.registrations.fetchRemove(fd);
+                }
+                return;
+            };
+            if (is_read) {
+                result.value_ptr.read_registered = true;
+            } else {
+                result.value_ptr.write_registered = true;
+            }
+        }
+    }
+
+    /// Unregister a file descriptor from all events.
+    pub fn unregister(self: *Self, fd: posix.fd_t) void {
+        if (self.registrations.fetchRemove(fd)) |entry| {
+            var changelist: [2]posix.system.Kevent = undefined;
+            var count: usize = 0;
+
+            if (entry.value.read_registered) {
+                changelist[count] = .{
+                    .ident = @intCast(fd),
+                    .filter = posix.system.EVFILT.READ,
+                    .flags = posix.system.EV.DELETE,
+                    .fflags = 0,
+                    .data = 0,
+                    .udata = 0,
+                };
+                count += 1;
+            }
+
+            if (entry.value.write_registered) {
+                changelist[count] = .{
+                    .ident = @intCast(fd),
+                    .filter = posix.system.EVFILT.WRITE,
+                    .flags = posix.system.EV.DELETE,
+                    .fflags = 0,
+                    .data = 0,
+                    .udata = 0,
+                };
+                count += 1;
+            }
+
+            if (count > 0) {
+                _ = posix.kevent(self.kq, changelist[0..count], &[_]posix.system.Kevent{}, null) catch |err| {
+                    std.log.err("KqueueIO: failed to unregister fd {d}: {s}", .{ fd, @errorName(err) });
+                };
+            }
+        }
+    }
+
+    /// Poll for I/O events and invoke callbacks.
+    /// Pass -1 for timeout_ms to block indefinitely.
+    /// Returns the number of events processed.
+    pub fn poll(self: *Self, timeout_ms: i32) usize {
+        const ts: ?posix.timespec = if (timeout_ms >= 0) .{
+            .sec = @intCast(@divFloor(timeout_ms, 1000)),
+            .nsec = @intCast(@mod(timeout_ms, 1000) * 1_000_000),
+        } else null;
+
+        const n = posix.kevent(
+            self.kq,
+            &[_]posix.system.Kevent{},
+            &self.events,
+            if (ts) |*t| t else null,
+        ) catch return 0;
+
+        // Process events and invoke callbacks
+        var processed: usize = 0;
+        for (self.events[0..n]) |event| {
+            // Skip wake events — they just interrupt the poll
+            if (event.filter == posix.system.EVFILT.USER and event.ident == wake_ident) {
+                continue;
+            }
+
+            const fd: posix.fd_t = @intCast(event.ident);
+
+            if (self.registrations.get(fd)) |entry| {
+                if (event.filter == posix.system.EVFILT.READ) {
+                    entry.read_cb.call(fd);
+                    processed += 1;
+                } else if (event.filter == posix.system.EVFILT.WRITE) {
+                    entry.write_cb.call(fd);
+                    processed += 1;
+                }
+            }
+        }
+
+        return processed;
+    }
+
+    /// Interrupt a blocking poll() call from another thread.
+    pub fn wake(self: *Self) void {
+        const changelist = [_]posix.system.Kevent{.{
+            .ident = wake_ident,
+            .filter = posix.system.EVFILT.USER,
+            .flags = 0,
+            .fflags = posix.system.NOTE.TRIGGER,
+            .data = 0,
+            .udata = 0,
+        }};
+        _ = posix.kevent(self.kq, &changelist, &[_]posix.system.Kevent{}, null) catch |err| {
+            std.log.err("KqueueIO: failed to wake: {s}", .{@errorName(err)});
+        };
+    }
+};
+
+// ============================================================================
+// Tests
+// ============================================================================
+
+test "KqueueIO basic read" {
+    var io = try KqueueIO.init(std.testing.allocator);
+    defer io.deinit();
+
+    const pipe_fds = try posix.pipe();
+    defer posix.close(pipe_fds[0]);
+    defer posix.close(pipe_fds[1]);
+
+    var read_called = false;
+    var read_fd: posix.fd_t = -1;
+
+    const Ctx = struct {
+        called: *bool,
+        fd: *posix.fd_t,
+    };
+
+    var ctx = Ctx{
+        .called = &read_called,
+        .fd = &read_fd,
+    };
+
+    io.registerRead(pipe_fds[0], .{
+        .ptr = @ptrCast(&ctx),
+        .callback = struct {
+            fn cb(ptr: ?*anyopaque, fd: posix.fd_t) void {
+                const c: *Ctx = @ptrCast(@alignCast(ptr.?));
+                c.called.* = true;
+                c.fd.* = fd;
+            }
+        }.cb,
+    });
+
+    _ = try posix.write(pipe_fds[1], "hello");
+
+    const count = io.poll(100);
+    try std.testing.expect(count > 0);
+    try std.testing.expect(read_called);
+    try std.testing.expectEqual(pipe_fds[0], read_fd);
+}
+
+test "KqueueIO unregister" {
+    var io = try KqueueIO.init(std.testing.allocator);
+    defer io.deinit();
+
+    const pipe_fds = try posix.pipe();
+    defer posix.close(pipe_fds[0]);
+    defer posix.close(pipe_fds[1]);
+
+    var called = false;
+
+    io.registerRead(pipe_fds[0], .{
+        .ptr = @ptrCast(&called),
+        .callback = struct {
+            fn cb(ptr: ?*anyopaque, _: posix.fd_t) void {
+                const c: *bool = @ptrCast(@alignCast(ptr.?));
+                c.* = true;
+            }
+        }.cb,
+    });
+
+    io.unregister(pipe_fds[0]);
+
+    _ = try posix.write(pipe_fds[1], "hello");
+
+    _ = io.poll(10);
+    try std.testing.expect(!called);
+}
+
+test "KqueueIO wake interrupts poll" {
+    var io = try KqueueIO.init(std.testing.allocator);
+    defer io.deinit();
+
+    io.wake();
+    const count = io.poll(1000);
+    try std.testing.expectEqual(@as(usize, 0), count);
+}
diff --git a/lib/platform/std/src/std.zig b/lib/platform/std/src/std.zig
index f025f36..639da70 100644
--- a/lib/platform/std/src/std.zig
+++ b/lib/platform/std/src/std.zig
@@ -22,6 +22,13 @@ pub const time = @import("impl/time.zig");
 pub const sync = @import("impl/sync.zig");
 pub const socket = @import("impl/socket.zig");
 pub const runtime = @import("impl/runtime.zig");
+pub const kqueue_io = if (@import("builtin").os.tag == .macos or
+    @import("builtin").os.tag == .freebsd or
+    @import("builtin").os.tag == .netbsd or
+    @import("builtin").os.tag == .openbsd)
+    @import("impl/kqueue_io.zig")
+else
+    struct {};
 
 // Convenience type re-exports
 pub const Mutex = sync.Mutex;
diff --git a/lib/trait/src/io.zig b/lib/trait/src/io.zig
new file mode 100644
index 0000000..07ada4c
--- /dev/null
+++ b/lib/trait/src/io.zig
@@ -0,0 +1,65 @@
+//! IO Trait — Async I/O service contract
+//!
+//! Validates that a type provides platform-specific async I/O multiplexing
+//! (kqueue on macOS/BSD, epoll on Linux, IOCP on Windows).
+//!
+//! This is a desktop/server-oriented trait. Embedded platforms typically
+//! use different I/O models and would not implement this trait.
+//!
+//! ## Contract
+//!
+//! ```zig
+//! const IOService = struct {
+//!     pub const ReadyCallback = struct {
+//!         ptr: ?*anyopaque,
+//!         callback: *const fn (ptr: ?*anyopaque, fd: std.posix.fd_t) void,
+//!     };
+//!
+//!     pub fn init(allocator: std.mem.Allocator) !IOService;
+//!     pub fn deinit(self: *IOService) void;
+//!     pub fn registerRead(self: *IOService, fd: fd_t, cb: ReadyCallback) void;
+//!     pub fn registerWrite(self: *IOService, fd: fd_t, cb: ReadyCallback) void;
+//!     pub fn unregister(self: *IOService, fd: fd_t) void;
+//!     pub fn poll(self: *IOService, timeout_ms: i32) usize;
+//!     pub fn wake(self: *IOService) void;
+//! };
+//! ```
+//!
+//! ## Usage
+//!
+//! ```zig
+//! pub fn UDP(comptime Rt: type) type {
+//!     comptime io.from(Rt.IO);  // validate IO service
+//!     return struct {
+//!         io: Rt.IO,
+//!         // ...
+//!     };
+//! }
+//! ```
+
+/// Validate that Impl is a valid IOService type
+///
+/// Required:
+/// - `ReadyCallback` type with `ptr` and `callback` fields
+/// - `init(Allocator) !Impl`
+/// - `deinit(*Impl) void`
+/// - `registerRead(*Impl, fd_t, ReadyCallback) void`
+/// - `registerWrite(*Impl, fd_t, ReadyCallback) void`
+/// - `unregister(*Impl, fd_t) void`
+/// - `poll(*Impl, i32) usize`
+/// - `wake(*Impl) void`
+pub fn from(comptime Impl: type) void {
+    comptime {
+        // Must have ReadyCallback type
+        if (!@hasDecl(Impl, "ReadyCallback")) @compileError("IOService missing ReadyCallback type");
+
+        // Must have required methods
+        if (!@hasDecl(Impl, "init")) @compileError("IOService missing init() function");
+        if (!@hasDecl(Impl, "deinit")) @compileError("IOService missing deinit() function");
+        if (!@hasDecl(Impl, "registerRead")) @compileError("IOService missing registerRead() function");
+        if (!@hasDecl(Impl, "registerWrite")) @compileError("IOService missing registerWrite() function");
+        if (!@hasDecl(Impl, "unregister")) @compileError("IOService missing unregister() function");
+        if (!@hasDecl(Impl, "poll")) @compileError("IOService missing poll() function");
+        if (!@hasDecl(Impl, "wake")) @compileError("IOService missing wake() function");
+    }
+}
diff --git a/lib/trait/src/task.zig b/lib/trait/src/task.zig
new file mode 100644
index 0000000..c201627
--- /dev/null
+++ b/lib/trait/src/task.zig
@@ -0,0 +1,125 @@
+//! Task — A type-erased callable unit of work
+//!
+//! Task wraps a pointer and a callback function, allowing any context
+//! to be executed through a uniform interface. Used by TimerService
+//! for delayed execution and by other scheduling primitives.
+//!
+//! ## Design
+//!
+//! - Zero allocation: Task itself doesn't allocate
+//! - Type-safe: Uses comptime to create type-safe callbacks
+//! - Platform agnostic: No OS dependencies
+//!
+//! ## Usage
+//!
+//! ```zig
+//! const MyContext = struct {
+//!     value: u32,
+//!     pub fn execute(self: *MyContext) void {
+//!         // Do work with self.value
+//!     }
+//! };
+//!
+//! var ctx = MyContext{ .value = 42 };
+//! const task = Task.init(MyContext, &ctx, MyContext.execute);
+//! task.run();
+//! ```
+
+/// A type-erased callable unit of work.
+pub const Task = struct {
+    /// Opaque pointer to the context
+    ptr: *anyopaque,
+    /// Callback function invoked with the context pointer
+    callback: *const fn (ptr: *anyopaque) void,
+
+    /// Create a task from a typed context and method.
+    pub fn init(
+        comptime T: type,
+        context: *T,
+        comptime method: fn (*T) void,
+    ) Task {
+        return .{
+            .ptr = @ptrCast(context),
+            .callback = struct {
+                fn wrapper(ptr: *anyopaque) void {
+                    const ctx: *T = @ptrCast(@alignCast(ptr));
+                    method(ctx);
+                }
+            }.wrapper,
+        };
+    }
+
+    /// Create a task from a raw pointer and callback.
+    pub fn initRaw(
+        ptr: *anyopaque,
+        callback: *const fn (ptr: *anyopaque) void,
+    ) Task {
+        return .{
+            .ptr = ptr,
+            .callback = callback,
+        };
+    }
+
+    /// Execute the task.
+    pub fn run(self: Task) void {
+        self.callback(self.ptr);
+    }
+
+    /// A no-op task that does nothing when run.
+    pub const noop: Task = .{
+        .ptr = undefined,
+        .callback = struct {
+            fn noopCallback(_: *anyopaque) void {}
+        }.noopCallback,
+    };
+};
+
+/// Handle to a scheduled timer, used for cancellation.
+pub const TimerHandle = struct {
+    id: u64,
+
+    /// A null handle representing no timer.
+    pub const null_handle: TimerHandle = .{ .id = 0 };
+
+    /// Check if this is a valid (non-null) handle.
+    pub fn isValid(self: TimerHandle) bool {
+        return self.id != 0;
+    }
+};
+
+// ============================================================================
+// Tests
+// ============================================================================
+
+const std = @import("std");
+
+test "Task.init creates callable task" {
+    const Context = struct {
+        called: bool = false,
+        value: u32 = 0,
+
+        fn execute(self: *@This()) void {
+            self.called = true;
+            self.value = 42;
+        }
+    };
+
+    var ctx = Context{};
+    const task = Task.init(Context, &ctx, Context.execute);
+
+    try std.testing.expect(!ctx.called);
+    task.run();
+    try std.testing.expect(ctx.called);
+    try std.testing.expectEqual(@as(u32, 42), ctx.value);
+}
+
+test "Task.noop does nothing" {
+    Task.noop.run();
+    Task.noop.run();
+}
+
+test "TimerHandle validity" {
+    try std.testing.expect(!TimerHandle.null_handle.isValid());
+    const valid = TimerHandle{ .id = 1 };
+    try std.testing.expect(valid.isValid());
+}
diff --git a/lib/trait/src/timer.zig b/lib/trait/src/timer.zig
new file mode 100644
index 0000000..b9fca3c
--- /dev/null
+++ b/lib/trait/src/timer.zig
@@ -0,0 +1,41 @@
+//! Timer Trait — Timer service contract
+//!
+//! Validates that a type provides timer scheduling capabilities.
+//! Used by KCP Mux for periodic update scheduling.
+//!
+//! ## Contract
+//!
+//! ```zig
+//! const TimerService = struct {
+//!     pub fn schedule(self: *TimerService, delay_ms: u32, task: Task) TimerHandle;
+//!     pub fn cancel(self: *TimerService, handle: TimerHandle) void;
+//! };
+//! ```
+//!
+//! ## Usage
+//!
+//! ```zig
+//! pub fn Mux(comptime Rt: type, comptime TimerSvc: type) type {
+//!     comptime timer.from(TimerSvc);  // validate
+//!     return struct {
+//!         timer_service: *TimerSvc,
+//!         // ...
+//!     };
+//! }
+//! ```
+
+const task_mod = @import("task.zig");
+pub const Task = task_mod.Task;
+pub const TimerHandle = task_mod.TimerHandle;
+
+/// Validate that Impl is a valid TimerService type
+///
+/// Required:
+/// - `schedule(*Impl, u32, Task) TimerHandle`
+/// - `cancel(*Impl, TimerHandle) void`
+pub fn from(comptime Impl: type) void {
+    comptime {
+        if (!@hasDecl(Impl, "schedule")) @compileError("TimerService missing schedule() function");
+        if (!@hasDecl(Impl, "cancel")) @compileError("TimerService missing cancel() function");
+    }
+}
diff --git a/lib/trait/src/trait.zig b/lib/trait/src/trait.zig
index 95ea23b..e43a940 100644
--- a/lib/trait/src/trait.zig
+++ b/lib/trait/src/trait.zig
@@ -44,6 +44,9 @@ pub const crypto = @import("crypto.zig");
 pub const net = @import("net.zig");
 pub const sync = @import("sync.zig");
 pub const spawner = @import("spawner.zig");
+pub const io = @import("io.zig");
+pub const timer = @import("timer.zig");
+pub const task = @import("task.zig");
 
 // Socket helpers
 pub const Ipv4Address = socket.Ipv4Address;
@@ -66,4 +69,7 @@ test {
     _ = net;
     _ = sync;
     _ = spawner;
+    _ = io;
+    _ = timer;
+    _ = task;
 }
